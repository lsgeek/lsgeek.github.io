<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[iOS大解密之Weak引用]]></title>
      <url>http://blog.hi996.com/2017/04/06/iosweaks/</url>
      <content type="text"><![CDATA[引言assign与weak有什么区别？面试的时候常常会被问到此问题，我们会回答weak修饰在对象释放时会自动变为nil,那么底层是怎么实现的呢？今天让我们来探讨一下，本文使用的runtime源码为大神提供的可编译版本objc4-706 storeWeak…与weak相关的操作，应该都调用了次方法，稍后看一下这个方法的实现，首先做一下准备工作 我首先在项目中定义了两个类Person、Like实现如下 1234567891011121314151617@interface Person : NSObject@property (atomic,weak) Like *like;- (void)logLikeAddress;@end@implementation Person- (void)logLikeAddress&#123; printf("%p",&amp;_like);&#125;@end// Like其实什么也没实现😂@interface Like : NSObject@end@implementation Like@end 其中main函数为 123456789101112131415161718void addLike(Person* person)&#123; Like *like = [[Like alloc] init]; printf("%p\n",like); [person logLikeAddress]; person.like = like;&#125;int main(int argc, const char * argv[])&#123; @autoreleasepool &#123; // insert code here... Person *person = [[Person alloc] init]; addLike(person); &#125; return 0;&#125; 准备工作已经就绪了，我们在Person的中weak修饰的属性下断点，并单步调试，会发现如下的函数调用栈 我们发现了关键的函数objc_storeWeak(...),下面我们要详细的探讨这一函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990template &lt;bool HaveOld, bool HaveNew, bool CrashIfDeallocating&gt;static id storeWeak(id *location, objc_object *newObj)&#123; assert(HaveOld || HaveNew); if (!HaveNew) assert(newObj == nil); Class previouslyInitializedClass = nil; id oldObj; // 新旧引用表创建 SideTable *oldTable; SideTable *newTable; // Acquire locks for old and new values. // Order by lock address to prevent lock ordering problems. // Retry if the old value changes underneath us. retry: if (HaveOld) &#123; // 获取旧引用表 oldObj = *location; oldTable = &amp;SideTables()[oldObj]; &#125; else &#123; oldTable = nil; &#125; if (HaveNew) &#123; // 获取新引用表 newTable = &amp;SideTables()[newObj]; &#125; else &#123; newTable = nil; &#125; // 加锁 SideTable::lockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable); // location 应该与 oldObj 保持一致，否则重新获取 if (HaveOld &amp;&amp; *location != oldObj) &#123; SideTable::unlockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable); goto retry; &#125; // Prevent a deadlock between the weak reference machinery // and the +initialize machinery by ensuring that no // weakly-referenced object has an un-+initialized isa. if (HaveNew &amp;&amp; newObj) &#123; Class cls = newObj-&gt;getIsa(); if (cls != previouslyInitializedClass &amp;&amp; !((objc_class *)cls)-&gt;isInitialized()) &#123; SideTable::unlockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable); _class_initialize(_class_getNonMetaClass(cls, (id)newObj)); // If this class is finished with +initialize then we're good. // If this class is still running +initialize on this thread // (i.e. +initialize called storeWeak on an instance of itself) // then we may proceed but it will appear initializing and // not yet initialized to the check above. // Instead set previouslyInitializedClass to recognize it on retry. previouslyInitializedClass = cls; goto retry; &#125; &#125; // Clean up old value, if any. 清除旧值 if (HaveOld) &#123; weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location); &#125; // Assign new value, if any. 设置新值 if (HaveNew) &#123; newObj = (objc_object *)weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, CrashIfDeallocating); // weak_register_no_lock returns nil if weak store should be rejected // Set is-weakly-referenced bit in refcount table. if (newObj &amp;&amp; !newObj-&gt;isTaggedPointer()) &#123; // 标记该对象是一个弱引用 newObj-&gt;setWeaklyReferenced_nolock(); &#125; // Do not set *location anywhere else. That would introduce a race. *location = (id)newObj; &#125; else &#123; // No new value. The storage is not changed. &#125; SideTable::unlockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable); return (id)newObj;&#125; 在此方法中，我们可以看见一些关键点， SideTable， weak_unregister_no_lock(...)， weak_register_no_lock（...），下面我们会逐一介绍 引用计数和弱引用依赖表 SideTableSideTable 是一个结构体，主要用于管理对象的引用计数和 weak 表。在 NSObject.mm 中声明其数据结构 1234567891011121314151617181920212223242526struct SideTable &#123; //自旋锁 spinlock_t slock; // 引用计数表 RefcountMap refcnts; // 弱引用表 weak_table_t weak_table; SideTable() &#123; memset(&amp;weak_table, 0, sizeof(weak_table)); &#125; ~SideTable() &#123; _objc_fatal("Do not delete SideTable."); &#125; void lock() &#123; slock.lock(); &#125; void unlock() &#123; slock.unlock(); &#125; // Address-ordered lock discipline for a pair of side tables. template&lt;bool HaveOld, bool HaveNew&gt; static void lockTwo(SideTable *lock1, SideTable *lock2); template&lt;bool HaveOld, bool HaveNew&gt; static void unlockTwo(SideTable *lock1, SideTable *lock2);&#125;; 对于该结构体中的slock,refcnts,暂时我们不做讨论，我们主要讨论与弱引用相关的weak_table作用，其中weak_table_t的结构如下 12345678910struct weak_table_t &#123; // 保存了所有指向指定对象的 weak 指针 weak_entry_t *weak_entries; // 存储空间 size_t num_entries; // 参与判断引用计数辅助量 uintptr_t mask; // hash key 最大偏移值 uintptr_t max_hash_displacement;&#125;; 这是一个全局弱引用表。使用不定类型对象的地址作为 key ，用weak_entry_t类型结构体对象作为value。其中的weak_entries成员，从字面意思上看，即为弱引用表入口。其实现也是这样的 123456789101112131415161718192021222324252627282930313233343536#define WEAK_INLINE_COUNT 4#define REFERRERS_OUT_OF_LINE 2struct weak_entry_t &#123; DisguisedPtr&lt;objc_object&gt; referent; union &#123; struct &#123; weak_referrer_t *referrers; uintptr_t out_of_line_ness : 2; uintptr_t num_refs : PTR_MINUS_2; uintptr_t mask; uintptr_t max_hash_displacement; &#125;; struct &#123; // out_of_line_ness field is low bits of inline_referrers[1] weak_referrer_t inline_referrers[WEAK_INLINE_COUNT]; &#125;; &#125;; bool out_of_line() &#123; return (out_of_line_ness == REFERRERS_OUT_OF_LINE); &#125; weak_entry_t&amp; operator=(const weak_entry_t&amp; other) &#123; memcpy(this, &amp;other, sizeof(other)); return *this; &#125; weak_entry_t(objc_object *newReferent, objc_object **newReferrer) : referent(newReferent) &#123; inline_referrers[0] = newReferrer; for (int i = 1; i &lt; WEAK_INLINE_COUNT; i++) &#123; inline_referrers[i] = nil; &#125; &#125;&#125;; 让我们回到storeWeak(...)函数中，获取oldTable,与newTable,发现调用的函数为&amp;SideTables()[newObj],&amp;SideTables()[oldObj],其中该方法的实现为 123456789alignas(StripedMap&lt;SideTable&gt;) static uint8_t SideTableBuf[sizeof(StripedMap&lt;SideTable&gt;)];static void SideTableInit() &#123; new (SideTableBuf) StripedMap&lt;SideTable&gt;();&#125;static StripedMap&lt;SideTable&gt;&amp; SideTables() &#123; return *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);&#125; 123456789101112131415161718192021222324252627282930template&lt;typename T&gt;class StripedMap &#123; enum &#123; CacheLineSize = 64 &#125;;#if TARGET_OS_EMBEDDED enum &#123; StripeCount = 8 &#125;;#else enum &#123; StripeCount = 64 &#125;;#endif struct PaddedT &#123; T value alignas(CacheLineSize); &#125;; PaddedT array[StripeCount]; static unsigned int indexForPointer(const void *p) &#123; uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(p); return ((addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)) % StripeCount; &#125; public: T&amp; operator[] (const void *p) &#123; return array[indexForPointer(p)].value; &#125; const T&amp; operator[] (const void *p) const &#123; return const_cast&lt;StripedMap&lt;T&gt;&gt;(this)[p]; &#125;&#125;; 在上面我们可以看出StripedMap是一个模板类（Template Class），通过传入类（结构体）参数，会动态修改在该类中的一个 array 成员存储的元素类型，并且其中提供了一个针对于地址的 hash 算法，用作存储key。可以说， StripedMap 提供了一套拥有将地址作为 key 的 hash table 解决方案，而该方案采用了模板类，是拥有泛型性的,在这个类中有一个 array 成员，用来存储 PaddedT 对象，并且其中对于 [] 符的重载定义中，会返回这个 PaddedT 的 value 成员，这个 value 就是我们传入的 T 泛型成员，也就是 SideTable 对象。在 array 的下标中，这里使用了 indexForPointer 方法通过位运算计算下标，实现了静态的 Hash Table。而在 weak_table 中，其成员 weak_entry会将传入对象的地址加以封装起来，并且其中也有访问全局弱引用表的入口 weak_register_no_lock(…)该方法将弱引用对象注册到弱引用表中，我们看一下它的具体实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859id weak_register_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id, bool crashIfDeallocating)&#123; // weak对象的引用 即like objc_object *referent = (objc_object *)referent_id; // 指向weak对象的引用的指针 即Person对象中的&amp;like 可理解为&amp;(person.like) objc_object **referrer = (objc_object **)referrer_id; //判断TaggedPointer if (!referent || referent-&gt;isTaggedPointer()) return referent_id; // ensure that the referenced object is viable 保证对象是可以访问的 bool deallocating; if (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123; deallocating = referent-&gt;rootIsDeallocating(); &#125; else &#123; BOOL (*allowsWeakReference)(objc_object *, SEL) = (BOOL(*)(objc_object *, SEL)) object_getMethodImplementation((id)referent, SEL_allowsWeakReference); if ((IMP)allowsWeakReference == _objc_msgForward) &#123; return nil; &#125; deallocating = ! (*allowsWeakReference)(referent, SEL_allowsWeakReference); &#125; if (deallocating) &#123; if (crashIfDeallocating) &#123; _objc_fatal("Cannot form weak reference to instance (%p) of " "class %s. It is possible that this object was " "over-released, or is in the process of deallocation.", (void*)referent, object_getClassName((id)referent)); &#125; else &#123; return nil; &#125; &#125; // now remember it and where it is being stored weak_entry_t *entry; if ((entry = weak_entry_for_referent(weak_table, referent))) &#123; append_referrer(entry, referrer); &#125; else &#123; // 该对象第一次插入 weak_entry_t new_entry(referent, referrer); // 是否需要扩容表长度 weak_grow_maybe(weak_table); // 插入表 weak_entry_insert(weak_table, &amp;new_entry); &#125; // Do not set *referrer. objc_storeWeak() requires that the // value not change. return referent_id;&#125; 总结一下，我们weak对象的引用,与指向weak对象的引用，传入此函数中，假设是首次保存此weak对象的引用，构建出weak_entry_t的实例new_entry,判断当前的弱引用表是否需要增加长度，然后将new_entry插入到弱引用表weak_table中；如若不是第一次保存，首先取出旧的entry，并将指向weak对象的引用（即&amp;(person.like)）保存在entry中。所以可以看出，一个entry中保存了所有指向该weak对象的弱引用 weak_unregister_no_lock(…)12345678910111213141516171819202122232425262728293031323334voidweak_unregister_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id)&#123; objc_object *referent = (objc_object *)referent_id; objc_object **referrer = (objc_object **)referrer_id; weak_entry_t *entry; if (!referent) return; if ((entry = weak_entry_for_referent(weak_table, referent))) &#123; remove_referrer(entry, referrer); bool empty = true; if (entry-&gt;out_of_line() &amp;&amp; entry-&gt;num_refs != 0) &#123; empty = false; &#125; else &#123; for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123; if (entry-&gt;inline_referrers[i]) &#123; empty = false; break; &#125; &#125; &#125; if (empty) &#123; weak_entry_remove(weak_table, entry); &#125; &#125; // Do not set *referrer = nil. objc_storeWeak() requires that the // value not change.&#125; 其中该方法就是remove_referrer(entry, referrer);,在entry中移除了referrer,弱引用表中不再保存指向该weak对象的引用 weak对象释放我们可以看见当一个被弱引用指向的对象释放时，会调用weak_clear_no_lock(...)方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445void weak_clear_no_lock(weak_table_t *weak_table, id referent_id) &#123; objc_object *referent = (objc_object *)referent_id; weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); if (entry == nil) &#123; /// XXX shouldn't happen, but does with mismatched CF/objc //printf("XXX no entry for clear deallocating %p\n", referent); return; &#125; // zero out references weak_referrer_t *referrers; size_t count; if (entry-&gt;out_of_line()) &#123; referrers = entry-&gt;referrers; count = TABLE_SIZE(entry); &#125; else &#123; referrers = entry-&gt;inline_referrers; count = WEAK_INLINE_COUNT; &#125; for (size_t i = 0; i &lt; count; ++i) &#123; objc_object **referrer = referrers[i]; if (referrer) &#123; if (*referrer == referent) &#123; //weak指向的对象，在释放时会被置nil的关键 *referrer = nil; &#125; else if (*referrer) &#123; _objc_inform("__weak variable at %p holds %p instead of %p. " "This is probably incorrect use of " "objc_storeWeak() and objc_loadWeak(). " "Break on objc_weak_error to debug.\n", referrer, (void*)*referrer, (void*)referent); objc_weak_error(); &#125; &#125; &#125; weak_entry_remove(weak_table, entry);&#125; 如方法中，通过referent,找到保存指向该对象的所有引用的实例entry，通过循环，将entry中的所有引用置为nil即可 weak引用表图解 参考资料http://www.jianshu.com/p/ef6d9bf8fe59http://kylinroc.github.io/objc-retain-release.htmlhttp://ios.jobbole.com/89012/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS大解密之Load方法]]></title>
      <url>http://blog.hi996.com/2017/03/08/iOS-load-methodDes/</url>
      <content type="text"><![CDATA[受益于苹果的封闭生态，开发者常常不必关注太多的底层细节，就能做出界面美观，性能优良的App，当然其中Apple也大方的开放出了少许的源码，例如Runtime源码,感谢http://blog.csdn.net/wotors/article/details/54426316 提供了可以编译成功的源码工程。 +load()我们来通过源码来探讨一下load方法的加载时机，和在父类，Category中的加载顺序 首先我们在+load方法中打上断点，看到如下的执行过程 通过runtime的源码我们可以找到load_images方法的具体实现，代码如下 123456789101112131415161718192021222324252627/************************************************************************ load_images* Process +load in the given images which are being mapped in by dyld.** Locking: write-locks runtimeLock and loadMethodLock**********************************************************************/extern bool hasLoadMethods(const headerType *mhdr);extern void prepare_load_methods(const headerType *mhdr);voidload_images(const char *path __unused, const struct mach_header *mh)&#123; // Return without taking locks if there are no +load methods here. if (!hasLoadMethods((const headerType *)mh)) return; recursive_mutex_locker_t lock(loadMethodLock); // Discover load methods &#123; rwlock_writer_t lock2(runtimeLock); prepare_load_methods((const headerType *)mh); &#125; // Call +load methods (without runtimeLock - re-entrant) call_load_methods();&#125; 在这里我们可以发现两个关键的方法，prepare_load_methods(…) call_load_methods() 12345678910111213141516171819202122void prepare_load_methods(const headerType *mhdr)&#123; size_t count, i; runtimeLock.assertWriting(); classref_t *classlist = _getObjc2NonlazyClassList(mhdr, &amp;count); for (i = 0; i &lt; count; i++) &#123; schedule_class_load(remapClass(classlist[i])); &#125; category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count); for (i = 0; i &lt; count; i++) &#123; category_t *cat = categorylist[i]; Class cls = remapClass(cat-&gt;cls); if (!cls) continue; // category for ignored weak-linked class realizeClass(cls); assert(cls-&gt;ISA()-&gt;isRealized()); add_category_to_loadable_list(cat); &#125;&#125; 12345678static void schedule_class_load(Class cls)&#123; if (cls-&gt;info &amp; CLS_LOADED) return; if (cls-&gt;superclass) schedule_class_load(cls-&gt;superclass); printf("%s\n\n",class_getName(cls)); add_class_to_loadable_list(cls); cls-&gt;info |= CLS_LOADED;&#125; 其中我们在void prepare_load_methods(const headerType *mhdr)方法中明显可以看出，先处理Class的相关信息，后处理Category的相关信息，在处理Class时会进入到static void schedule_class_load(Class cls)方法中,在此方法中会递归的寻找到父类，然后调用其add_class_to_loadable_list(cls)的信息 1234567891011121314151617181920212223242526void add_class_to_loadable_list(Class cls)&#123; IMP method; loadMethodLock.assertLocked(); method = cls-&gt;getLoadMethod(); if (!method) return; // Don't bother if cls has no +load method if (PrintLoading) &#123; _objc_inform("LOAD: class '%s' scheduled for +load", cls-&gt;nameForLogging()); &#125; if (loadable_classes_used == loadable_classes_allocated) &#123; loadable_classes_allocated = loadable_classes_allocated*2 + 16; loadable_classes = (struct loadable_class *) realloc(loadable_classes, loadable_classes_allocated * sizeof(struct loadable_class)); &#125; loadable_classes[loadable_classes_used].cls = cls; loadable_classes[loadable_classes_used].method = method; loadable_classes_used++;&#125; 在这里判断了Class中是否实现了+load方法,若实现了把该Class顺序存储到loadable_classes中,Category同理也调用了相关方法，将实现的load方法的category添加到了list中，如下图 12345678910111213141516171819202122232425262728293031323334/************************************************************************ add_category_to_loadable_list* Category cat's parent class exists and the category has been attached* to its class. Schedule this category for +load after its parent class* becomes connected and has its own +load method called.**********************************************************************/void add_category_to_loadable_list(Category cat)&#123; IMP method; loadMethodLock.assertLocked(); method = _category_getLoadMethod(cat); // Don't bother if cat has no +load method if (!method) return; if (PrintLoading) &#123; _objc_inform("LOAD: category '%s(%s)' scheduled for +load", _category_getClassName(cat), _category_getName(cat)); &#125; if (loadable_categories_used == loadable_categories_allocated) &#123; loadable_categories_allocated = loadable_categories_allocated*2 + 16; loadable_categories = (struct loadable_category *) realloc(loadable_categories, loadable_categories_allocated * sizeof(struct loadable_category)); &#125; loadable_categories[loadable_categories_used].cat = cat; loadable_categories[loadable_categories_used].method = method; loadable_categories_used++;&#125; 到这里prepare_load_methods(…)这个方法的使命就算结束了，我们找到了可以执行load方法的Class和Category，接下来让我们看一下执行的步骤 1234567891011121314151617181920212223242526272829void call_load_methods(void)&#123; static bool loading = NO; bool more_categories; loadMethodLock.assertLocked(); // Re-entrant calls do nothing; the outermost call will finish the job. if (loading) return; loading = YES; void *pool = objc_autoreleasePoolPush(); do &#123; // 1. Repeatedly call class +loads until there aren't any more while (loadable_classes_used &gt; 0) &#123; call_class_loads(); &#125; // 2. Call category +loads ONCE more_categories = call_category_loads(); // 3. Run more +loads if there are classes OR more untried categories &#125; while (loadable_classes_used &gt; 0 || more_categories); objc_autoreleasePoolPop(pool); loading = NO;&#125; 关键方法 call_class_loads() call_category_loads(),可以看出是先执行的Class中的load方法，再执行Category中的load方法，下面是两个方法的具体实现 123456789101112131415161718192021222324252627282930313233/************************************************************************ call_class_loads* Call all pending class +load methods.* If new classes become loadable, +load is NOT called for them.** Called only by call_load_methods().**********************************************************************/static void call_class_loads(void)&#123; int i; // Detach current loadable list. struct loadable_class *classes = loadable_classes; int used = loadable_classes_used; loadable_classes = nil; loadable_classes_allocated = 0; loadable_classes_used = 0; // Call all +loads for the detached list. for (i = 0; i &lt; used; i++) &#123; Class cls = classes[i].cls; load_method_t load_method = (load_method_t)classes[i].method; if (!cls) continue; if (PrintLoading) &#123; _objc_inform("LOAD: +[%s load]\n", cls-&gt;nameForLogging()); &#125; (*load_method)(cls, SEL_load); &#125; // Destroy the detached list. if (classes) free(classes);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/************************************************************************ call_category_loads* Call some pending category +load methods.* The parent class of the +load-implementing categories has all of * its categories attached, in case some are lazily waiting for +initalize.* Don&apos;t call +load unless the parent class is connected.* If new categories become loadable, +load is NOT called, and they * are added to the end of the loadable list, and we return TRUE.* Return FALSE if no new categories became loadable.** Called only by call_load_methods().**********************************************************************/static bool call_category_loads(void)&#123; int i, shift; bool new_categories_added = NO; // Detach current loadable list. struct loadable_category *cats = loadable_categories; int used = loadable_categories_used; int allocated = loadable_categories_allocated; loadable_categories = nil; loadable_categories_allocated = 0; loadable_categories_used = 0; // Call all +loads for the detached list. for (i = 0; i &lt; used; i++) &#123; Category cat = cats[i].cat; load_method_t load_method = (load_method_t)cats[i].method; Class cls; if (!cat) continue; cls = _category_getClass(cat); if (cls &amp;&amp; cls-&gt;isLoadable()) &#123; if (PrintLoading) &#123; _objc_inform(&quot;LOAD: +[%s(%s) load]\n&quot;, cls-&gt;nameForLogging(), _category_getName(cat)); &#125; (*load_method)(cls, SEL_load); cats[i].cat = nil; &#125; &#125; // Compact detached list (order-preserving) shift = 0; for (i = 0; i &lt; used; i++) &#123; if (cats[i].cat) &#123; cats[i-shift] = cats[i]; &#125; else &#123; shift++; &#125; &#125; used -= shift; // Copy any new +load candidates from the new list to the detached list. new_categories_added = (loadable_categories_used &gt; 0); for (i = 0; i &lt; loadable_categories_used; i++) &#123; if (used == allocated) &#123; allocated = allocated*2 + 16; cats = (struct loadable_category *) realloc(cats, allocated * sizeof(struct loadable_category)); &#125; cats[used++] = loadable_categories[i]; &#125; // Destroy the new list. if (loadable_categories) free(loadable_categories); // Reattach the (now augmented) detached list. // But if there&apos;s nothing left to load, destroy the list. if (used) &#123; loadable_categories = cats; loadable_categories_used = used; loadable_categories_allocated = allocated; &#125; else &#123; if (cats) free(cats); loadable_categories = nil; loadable_categories_used = 0; loadable_categories_allocated = 0; &#125; if (PrintLoading) &#123; if (loadable_categories_used != 0) &#123; _objc_inform(&quot;LOAD: %d categories still waiting for +load\n&quot;, loadable_categories_used); &#125; &#125; return new_categories_added;&#125; 总结+load方法通过函数指针调用，而不是objc_msgSend+load方法的调用时机是在Runtime初始化的时候，其中的调用顺序是父类-&gt;子类-&gt;分类，其中默认调用一次，在Class中和Category中都实现了load方法，则在两者之间都会调用，且在子类实现+load方法时不需要显示的调用[super load]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://blog.hi996.com/2016/10/18/hello-world/</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
