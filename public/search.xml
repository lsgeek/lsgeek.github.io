<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[iOSå¤§è§£å¯†ä¹‹Weakå¼•ç”¨]]></title>
      <url>http://blog.hi996.com/2017/04/06/iosweaks/</url>
      <content type="text"><![CDATA[å¼•è¨€assignä¸Žweakæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿé¢è¯•çš„æ—¶å€™å¸¸å¸¸ä¼šè¢«é—®åˆ°æ­¤é—®é¢˜ï¼Œæˆ‘ä»¬ä¼šå›žç­”weakä¿®é¥°åœ¨å¯¹è±¡é‡Šæ”¾æ—¶ä¼šè‡ªåŠ¨å˜ä¸ºnil,é‚£ä¹ˆåº•å±‚æ˜¯æ€Žä¹ˆå®žçŽ°çš„å‘¢ï¼Ÿä»Šå¤©è®©æˆ‘ä»¬æ¥æŽ¢è®¨ä¸€ä¸‹ï¼Œæœ¬æ–‡ä½¿ç”¨çš„runtimeæºç ä¸ºå¤§ç¥žæä¾›çš„å¯ç¼–è¯‘ç‰ˆæœ¬objc4-706 storeWeakâ€¦ä¸Žweakç›¸å…³çš„æ“ä½œï¼Œåº”è¯¥éƒ½è°ƒç”¨äº†æ¬¡æ–¹æ³•ï¼Œç¨åŽçœ‹ä¸€ä¸‹è¿™ä¸ªæ–¹æ³•çš„å®žçŽ°ï¼Œé¦–å…ˆåšä¸€ä¸‹å‡†å¤‡å·¥ä½œ æˆ‘é¦–å…ˆåœ¨é¡¹ç›®ä¸­å®šä¹‰äº†ä¸¤ä¸ªç±»Personã€Likeå®žçŽ°å¦‚ä¸‹ 1234567891011121314151617@interface Person : NSObject@property (atomic,weak) Like *like;- (void)logLikeAddress;@end@implementation Person- (void)logLikeAddress&#123; printf("%p",&amp;_like);&#125;@end// Likeå…¶å®žä»€ä¹ˆä¹Ÿæ²¡å®žçŽ°ðŸ˜‚@interface Like : NSObject@end@implementation Like@end å…¶ä¸­mainå‡½æ•°ä¸º 123456789101112131415161718void addLike(Person* person)&#123; Like *like = [[Like alloc] init]; printf("%p\n",like); [person logLikeAddress]; person.like = like;&#125;int main(int argc, const char * argv[])&#123; @autoreleasepool &#123; // insert code here... Person *person = [[Person alloc] init]; addLike(person); &#125; return 0;&#125; å‡†å¤‡å·¥ä½œå·²ç»å°±ç»ªäº†ï¼Œæˆ‘ä»¬åœ¨Personçš„ä¸­weakä¿®é¥°çš„å±žæ€§ä¸‹æ–­ç‚¹ï¼Œå¹¶å•æ­¥è°ƒè¯•ï¼Œä¼šå‘çŽ°å¦‚ä¸‹çš„å‡½æ•°è°ƒç”¨æ ˆ æˆ‘ä»¬å‘çŽ°äº†å…³é”®çš„å‡½æ•°objc_storeWeak(...),ä¸‹é¢æˆ‘ä»¬è¦è¯¦ç»†çš„æŽ¢è®¨è¿™ä¸€å‡½æ•° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990template &lt;bool HaveOld, bool HaveNew, bool CrashIfDeallocating&gt;static id storeWeak(id *location, objc_object *newObj)&#123; assert(HaveOld || HaveNew); if (!HaveNew) assert(newObj == nil); Class previouslyInitializedClass = nil; id oldObj; // æ–°æ—§å¼•ç”¨è¡¨åˆ›å»º SideTable *oldTable; SideTable *newTable; // Acquire locks for old and new values. // Order by lock address to prevent lock ordering problems. // Retry if the old value changes underneath us. retry: if (HaveOld) &#123; // èŽ·å–æ—§å¼•ç”¨è¡¨ oldObj = *location; oldTable = &amp;SideTables()[oldObj]; &#125; else &#123; oldTable = nil; &#125; if (HaveNew) &#123; // èŽ·å–æ–°å¼•ç”¨è¡¨ newTable = &amp;SideTables()[newObj]; &#125; else &#123; newTable = nil; &#125; // åŠ é” SideTable::lockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable); // location åº”è¯¥ä¸Ž oldObj ä¿æŒä¸€è‡´ï¼Œå¦åˆ™é‡æ–°èŽ·å– if (HaveOld &amp;&amp; *location != oldObj) &#123; SideTable::unlockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable); goto retry; &#125; // Prevent a deadlock between the weak reference machinery // and the +initialize machinery by ensuring that no // weakly-referenced object has an un-+initialized isa. if (HaveNew &amp;&amp; newObj) &#123; Class cls = newObj-&gt;getIsa(); if (cls != previouslyInitializedClass &amp;&amp; !((objc_class *)cls)-&gt;isInitialized()) &#123; SideTable::unlockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable); _class_initialize(_class_getNonMetaClass(cls, (id)newObj)); // If this class is finished with +initialize then we're good. // If this class is still running +initialize on this thread // (i.e. +initialize called storeWeak on an instance of itself) // then we may proceed but it will appear initializing and // not yet initialized to the check above. // Instead set previouslyInitializedClass to recognize it on retry. previouslyInitializedClass = cls; goto retry; &#125; &#125; // Clean up old value, if any. æ¸…é™¤æ—§å€¼ if (HaveOld) &#123; weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location); &#125; // Assign new value, if any. è®¾ç½®æ–°å€¼ if (HaveNew) &#123; newObj = (objc_object *)weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, CrashIfDeallocating); // weak_register_no_lock returns nil if weak store should be rejected // Set is-weakly-referenced bit in refcount table. if (newObj &amp;&amp; !newObj-&gt;isTaggedPointer()) &#123; // æ ‡è®°è¯¥å¯¹è±¡æ˜¯ä¸€ä¸ªå¼±å¼•ç”¨ newObj-&gt;setWeaklyReferenced_nolock(); &#125; // Do not set *location anywhere else. That would introduce a race. *location = (id)newObj; &#125; else &#123; // No new value. The storage is not changed. &#125; SideTable::unlockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable); return (id)newObj;&#125; åœ¨æ­¤æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹è§ä¸€äº›å…³é”®ç‚¹ï¼Œ SideTableï¼Œ weak_unregister_no_lock(...)ï¼Œ weak_register_no_lockï¼ˆ...ï¼‰ï¼Œä¸‹é¢æˆ‘ä»¬ä¼šé€ä¸€ä»‹ç» å¼•ç”¨è®¡æ•°å’Œå¼±å¼•ç”¨ä¾èµ–è¡¨ SideTableSideTable æ˜¯ä¸€ä¸ªç»“æž„ä½“ï¼Œä¸»è¦ç”¨äºŽç®¡ç†å¯¹è±¡çš„å¼•ç”¨è®¡æ•°å’Œ weak è¡¨ã€‚åœ¨ NSObject.mm ä¸­å£°æ˜Žå…¶æ•°æ®ç»“æž„ 1234567891011121314151617181920212223242526struct SideTable &#123; //è‡ªæ—‹é” spinlock_t slock; // å¼•ç”¨è®¡æ•°è¡¨ RefcountMap refcnts; // å¼±å¼•ç”¨è¡¨ weak_table_t weak_table; SideTable() &#123; memset(&amp;weak_table, 0, sizeof(weak_table)); &#125; ~SideTable() &#123; _objc_fatal("Do not delete SideTable."); &#125; void lock() &#123; slock.lock(); &#125; void unlock() &#123; slock.unlock(); &#125; // Address-ordered lock discipline for a pair of side tables. template&lt;bool HaveOld, bool HaveNew&gt; static void lockTwo(SideTable *lock1, SideTable *lock2); template&lt;bool HaveOld, bool HaveNew&gt; static void unlockTwo(SideTable *lock1, SideTable *lock2);&#125;; å¯¹äºŽè¯¥ç»“æž„ä½“ä¸­çš„slock,refcnts,æš‚æ—¶æˆ‘ä»¬ä¸åšè®¨è®ºï¼Œæˆ‘ä»¬ä¸»è¦è®¨è®ºä¸Žå¼±å¼•ç”¨ç›¸å…³çš„weak_tableä½œç”¨ï¼Œå…¶ä¸­weak_table_tçš„ç»“æž„å¦‚ä¸‹ 12345678910struct weak_table_t &#123; // ä¿å­˜äº†æ‰€æœ‰æŒ‡å‘æŒ‡å®šå¯¹è±¡çš„ weak æŒ‡é’ˆ weak_entry_t *weak_entries; // å­˜å‚¨ç©ºé—´ size_t num_entries; // å‚ä¸Žåˆ¤æ–­å¼•ç”¨è®¡æ•°è¾…åŠ©é‡ uintptr_t mask; // hash key æœ€å¤§åç§»å€¼ uintptr_t max_hash_displacement;&#125;; è¿™æ˜¯ä¸€ä¸ªå…¨å±€å¼±å¼•ç”¨è¡¨ã€‚ä½¿ç”¨ä¸å®šç±»åž‹å¯¹è±¡çš„åœ°å€ä½œä¸º key ï¼Œç”¨weak_entry_tç±»åž‹ç»“æž„ä½“å¯¹è±¡ä½œä¸ºvalueã€‚å…¶ä¸­çš„weak_entriesæˆå‘˜ï¼Œä»Žå­—é¢æ„æ€ä¸Šçœ‹ï¼Œå³ä¸ºå¼±å¼•ç”¨è¡¨å…¥å£ã€‚å…¶å®žçŽ°ä¹Ÿæ˜¯è¿™æ ·çš„ 123456789101112131415161718192021222324252627282930313233343536#define WEAK_INLINE_COUNT 4#define REFERRERS_OUT_OF_LINE 2struct weak_entry_t &#123; DisguisedPtr&lt;objc_object&gt; referent; union &#123; struct &#123; weak_referrer_t *referrers; uintptr_t out_of_line_ness : 2; uintptr_t num_refs : PTR_MINUS_2; uintptr_t mask; uintptr_t max_hash_displacement; &#125;; struct &#123; // out_of_line_ness field is low bits of inline_referrers[1] weak_referrer_t inline_referrers[WEAK_INLINE_COUNT]; &#125;; &#125;; bool out_of_line() &#123; return (out_of_line_ness == REFERRERS_OUT_OF_LINE); &#125; weak_entry_t&amp; operator=(const weak_entry_t&amp; other) &#123; memcpy(this, &amp;other, sizeof(other)); return *this; &#125; weak_entry_t(objc_object *newReferent, objc_object **newReferrer) : referent(newReferent) &#123; inline_referrers[0] = newReferrer; for (int i = 1; i &lt; WEAK_INLINE_COUNT; i++) &#123; inline_referrers[i] = nil; &#125; &#125;&#125;; è®©æˆ‘ä»¬å›žåˆ°storeWeak(...)å‡½æ•°ä¸­ï¼ŒèŽ·å–oldTable,ä¸ŽnewTable,å‘çŽ°è°ƒç”¨çš„å‡½æ•°ä¸º&amp;SideTables()[newObj],&amp;SideTables()[oldObj],å…¶ä¸­è¯¥æ–¹æ³•çš„å®žçŽ°ä¸º 123456789alignas(StripedMap&lt;SideTable&gt;) static uint8_t SideTableBuf[sizeof(StripedMap&lt;SideTable&gt;)];static void SideTableInit() &#123; new (SideTableBuf) StripedMap&lt;SideTable&gt;();&#125;static StripedMap&lt;SideTable&gt;&amp; SideTables() &#123; return *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);&#125; 123456789101112131415161718192021222324252627282930template&lt;typename T&gt;class StripedMap &#123; enum &#123; CacheLineSize = 64 &#125;;#if TARGET_OS_EMBEDDED enum &#123; StripeCount = 8 &#125;;#else enum &#123; StripeCount = 64 &#125;;#endif struct PaddedT &#123; T value alignas(CacheLineSize); &#125;; PaddedT array[StripeCount]; static unsigned int indexForPointer(const void *p) &#123; uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(p); return ((addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)) % StripeCount; &#125; public: T&amp; operator[] (const void *p) &#123; return array[indexForPointer(p)].value; &#125; const T&amp; operator[] (const void *p) const &#123; return const_cast&lt;StripedMap&lt;T&gt;&gt;(this)[p]; &#125;&#125;; åœ¨ä¸Šé¢æˆ‘ä»¬å¯ä»¥çœ‹å‡ºStripedMapæ˜¯ä¸€ä¸ªæ¨¡æ¿ç±»ï¼ˆTemplate Classï¼‰ï¼Œé€šè¿‡ä¼ å…¥ç±»ï¼ˆç»“æž„ä½“ï¼‰å‚æ•°ï¼Œä¼šåŠ¨æ€ä¿®æ”¹åœ¨è¯¥ç±»ä¸­çš„ä¸€ä¸ª array æˆå‘˜å­˜å‚¨çš„å…ƒç´ ç±»åž‹ï¼Œå¹¶ä¸”å…¶ä¸­æä¾›äº†ä¸€ä¸ªé’ˆå¯¹äºŽåœ°å€çš„ hash ç®—æ³•ï¼Œç”¨ä½œå­˜å‚¨keyã€‚å¯ä»¥è¯´ï¼Œ StripedMap æä¾›äº†ä¸€å¥—æ‹¥æœ‰å°†åœ°å€ä½œä¸º key çš„ hash table è§£å†³æ–¹æ¡ˆï¼Œè€Œè¯¥æ–¹æ¡ˆé‡‡ç”¨äº†æ¨¡æ¿ç±»ï¼Œæ˜¯æ‹¥æœ‰æ³›åž‹æ€§çš„,åœ¨è¿™ä¸ªç±»ä¸­æœ‰ä¸€ä¸ª array æˆå‘˜ï¼Œç”¨æ¥å­˜å‚¨ PaddedT å¯¹è±¡ï¼Œå¹¶ä¸”å…¶ä¸­å¯¹äºŽ [] ç¬¦çš„é‡è½½å®šä¹‰ä¸­ï¼Œä¼šè¿”å›žè¿™ä¸ª PaddedT çš„ value æˆå‘˜ï¼Œè¿™ä¸ª value å°±æ˜¯æˆ‘ä»¬ä¼ å…¥çš„ T æ³›åž‹æˆå‘˜ï¼Œä¹Ÿå°±æ˜¯ SideTable å¯¹è±¡ã€‚åœ¨ array çš„ä¸‹æ ‡ä¸­ï¼Œè¿™é‡Œä½¿ç”¨äº† indexForPointer æ–¹æ³•é€šè¿‡ä½è¿ç®—è®¡ç®—ä¸‹æ ‡ï¼Œå®žçŽ°äº†é™æ€çš„ Hash Tableã€‚è€Œåœ¨ weak_table ä¸­ï¼Œå…¶æˆå‘˜ weak_entryä¼šå°†ä¼ å…¥å¯¹è±¡çš„åœ°å€åŠ ä»¥å°è£…èµ·æ¥ï¼Œå¹¶ä¸”å…¶ä¸­ä¹Ÿæœ‰è®¿é—®å…¨å±€å¼±å¼•ç”¨è¡¨çš„å…¥å£ weak_register_no_lock(â€¦)è¯¥æ–¹æ³•å°†å¼±å¼•ç”¨å¯¹è±¡æ³¨å†Œåˆ°å¼±å¼•ç”¨è¡¨ä¸­ï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸‹å®ƒçš„å…·ä½“å®žçŽ° 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859id weak_register_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id, bool crashIfDeallocating)&#123; // weakå¯¹è±¡çš„å¼•ç”¨ å³like objc_object *referent = (objc_object *)referent_id; // æŒ‡å‘weakå¯¹è±¡çš„å¼•ç”¨çš„æŒ‡é’ˆ å³Personå¯¹è±¡ä¸­çš„&amp;like å¯ç†è§£ä¸º&amp;(person.like) objc_object **referrer = (objc_object **)referrer_id; //åˆ¤æ–­TaggedPointer if (!referent || referent-&gt;isTaggedPointer()) return referent_id; // ensure that the referenced object is viable ä¿è¯å¯¹è±¡æ˜¯å¯ä»¥è®¿é—®çš„ bool deallocating; if (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123; deallocating = referent-&gt;rootIsDeallocating(); &#125; else &#123; BOOL (*allowsWeakReference)(objc_object *, SEL) = (BOOL(*)(objc_object *, SEL)) object_getMethodImplementation((id)referent, SEL_allowsWeakReference); if ((IMP)allowsWeakReference == _objc_msgForward) &#123; return nil; &#125; deallocating = ! (*allowsWeakReference)(referent, SEL_allowsWeakReference); &#125; if (deallocating) &#123; if (crashIfDeallocating) &#123; _objc_fatal("Cannot form weak reference to instance (%p) of " "class %s. It is possible that this object was " "over-released, or is in the process of deallocation.", (void*)referent, object_getClassName((id)referent)); &#125; else &#123; return nil; &#125; &#125; // now remember it and where it is being stored weak_entry_t *entry; if ((entry = weak_entry_for_referent(weak_table, referent))) &#123; append_referrer(entry, referrer); &#125; else &#123; // è¯¥å¯¹è±¡ç¬¬ä¸€æ¬¡æ’å…¥ weak_entry_t new_entry(referent, referrer); // æ˜¯å¦éœ€è¦æ‰©å®¹è¡¨é•¿åº¦ weak_grow_maybe(weak_table); // æ’å…¥è¡¨ weak_entry_insert(weak_table, &amp;new_entry); &#125; // Do not set *referrer. objc_storeWeak() requires that the // value not change. return referent_id;&#125; æ€»ç»“ä¸€ä¸‹ï¼Œæˆ‘ä»¬weakå¯¹è±¡çš„å¼•ç”¨,ä¸ŽæŒ‡å‘weakå¯¹è±¡çš„å¼•ç”¨ï¼Œä¼ å…¥æ­¤å‡½æ•°ä¸­ï¼Œå‡è®¾æ˜¯é¦–æ¬¡ä¿å­˜æ­¤weakå¯¹è±¡çš„å¼•ç”¨ï¼Œæž„å»ºå‡ºweak_entry_tçš„å®žä¾‹new_entry,åˆ¤æ–­å½“å‰çš„å¼±å¼•ç”¨è¡¨æ˜¯å¦éœ€è¦å¢žåŠ é•¿åº¦ï¼Œç„¶åŽå°†new_entryæ’å…¥åˆ°å¼±å¼•ç”¨è¡¨weak_tableä¸­ï¼›å¦‚è‹¥ä¸æ˜¯ç¬¬ä¸€æ¬¡ä¿å­˜ï¼Œé¦–å…ˆå–å‡ºæ—§çš„entryï¼Œå¹¶å°†æŒ‡å‘weakå¯¹è±¡çš„å¼•ç”¨ï¼ˆå³&amp;(person.like)ï¼‰ä¿å­˜åœ¨entryä¸­ã€‚æ‰€ä»¥å¯ä»¥çœ‹å‡ºï¼Œä¸€ä¸ªentryä¸­ä¿å­˜äº†æ‰€æœ‰æŒ‡å‘è¯¥weakå¯¹è±¡çš„å¼±å¼•ç”¨ weak_unregister_no_lock(â€¦)12345678910111213141516171819202122232425262728293031323334voidweak_unregister_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id)&#123; objc_object *referent = (objc_object *)referent_id; objc_object **referrer = (objc_object **)referrer_id; weak_entry_t *entry; if (!referent) return; if ((entry = weak_entry_for_referent(weak_table, referent))) &#123; remove_referrer(entry, referrer); bool empty = true; if (entry-&gt;out_of_line() &amp;&amp; entry-&gt;num_refs != 0) &#123; empty = false; &#125; else &#123; for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123; if (entry-&gt;inline_referrers[i]) &#123; empty = false; break; &#125; &#125; &#125; if (empty) &#123; weak_entry_remove(weak_table, entry); &#125; &#125; // Do not set *referrer = nil. objc_storeWeak() requires that the // value not change.&#125; å…¶ä¸­è¯¥æ–¹æ³•å°±æ˜¯remove_referrer(entry, referrer);,åœ¨entryä¸­ç§»é™¤äº†referrer,å¼±å¼•ç”¨è¡¨ä¸­ä¸å†ä¿å­˜æŒ‡å‘è¯¥weakå¯¹è±¡çš„å¼•ç”¨ weakå¯¹è±¡é‡Šæ”¾æˆ‘ä»¬å¯ä»¥çœ‹è§å½“ä¸€ä¸ªè¢«å¼±å¼•ç”¨æŒ‡å‘çš„å¯¹è±¡é‡Šæ”¾æ—¶ï¼Œä¼šè°ƒç”¨weak_clear_no_lock(...)æ–¹æ³• 123456789101112131415161718192021222324252627282930313233343536373839404142434445void weak_clear_no_lock(weak_table_t *weak_table, id referent_id) &#123; objc_object *referent = (objc_object *)referent_id; weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); if (entry == nil) &#123; /// XXX shouldn't happen, but does with mismatched CF/objc //printf("XXX no entry for clear deallocating %p\n", referent); return; &#125; // zero out references weak_referrer_t *referrers; size_t count; if (entry-&gt;out_of_line()) &#123; referrers = entry-&gt;referrers; count = TABLE_SIZE(entry); &#125; else &#123; referrers = entry-&gt;inline_referrers; count = WEAK_INLINE_COUNT; &#125; for (size_t i = 0; i &lt; count; ++i) &#123; objc_object **referrer = referrers[i]; if (referrer) &#123; if (*referrer == referent) &#123; //weakæŒ‡å‘çš„å¯¹è±¡ï¼Œåœ¨é‡Šæ”¾æ—¶ä¼šè¢«ç½®nilçš„å…³é”® *referrer = nil; &#125; else if (*referrer) &#123; _objc_inform("__weak variable at %p holds %p instead of %p. " "This is probably incorrect use of " "objc_storeWeak() and objc_loadWeak(). " "Break on objc_weak_error to debug.\n", referrer, (void*)*referrer, (void*)referent); objc_weak_error(); &#125; &#125; &#125; weak_entry_remove(weak_table, entry);&#125; å¦‚æ–¹æ³•ä¸­ï¼Œé€šè¿‡referent,æ‰¾åˆ°ä¿å­˜æŒ‡å‘è¯¥å¯¹è±¡çš„æ‰€æœ‰å¼•ç”¨çš„å®žä¾‹entryï¼Œé€šè¿‡å¾ªçŽ¯ï¼Œå°†entryä¸­çš„æ‰€æœ‰å¼•ç”¨ç½®ä¸ºnilå³å¯ weakå¼•ç”¨è¡¨å›¾è§£ å‚è€ƒèµ„æ–™http://www.jianshu.com/p/ef6d9bf8fe59http://kylinroc.github.io/objc-retain-release.htmlhttp://ios.jobbole.com/89012/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOSå¤§è§£å¯†ä¹‹Loadæ–¹æ³•]]></title>
      <url>http://blog.hi996.com/2017/03/08/iOS-load-methodDes/</url>
      <content type="text"><![CDATA[å—ç›ŠäºŽè‹¹æžœçš„å°é—­ç”Ÿæ€ï¼Œå¼€å‘è€…å¸¸å¸¸ä¸å¿…å…³æ³¨å¤ªå¤šçš„åº•å±‚ç»†èŠ‚ï¼Œå°±èƒ½åšå‡ºç•Œé¢ç¾Žè§‚ï¼Œæ€§èƒ½ä¼˜è‰¯çš„Appï¼Œå½“ç„¶å…¶ä¸­Appleä¹Ÿå¤§æ–¹çš„å¼€æ”¾å‡ºäº†å°‘è®¸çš„æºç ï¼Œä¾‹å¦‚Runtimeæºç ,æ„Ÿè°¢http://blog.csdn.net/wotors/article/details/54426316 æä¾›äº†å¯ä»¥ç¼–è¯‘æˆåŠŸçš„æºç å·¥ç¨‹ã€‚ +load()æˆ‘ä»¬æ¥é€šè¿‡æºç æ¥æŽ¢è®¨ä¸€ä¸‹loadæ–¹æ³•çš„åŠ è½½æ—¶æœºï¼Œå’Œåœ¨çˆ¶ç±»ï¼ŒCategoryä¸­çš„åŠ è½½é¡ºåº é¦–å…ˆæˆ‘ä»¬åœ¨+loadæ–¹æ³•ä¸­æ‰“ä¸Šæ–­ç‚¹ï¼Œçœ‹åˆ°å¦‚ä¸‹çš„æ‰§è¡Œè¿‡ç¨‹ é€šè¿‡runtimeçš„æºç æˆ‘ä»¬å¯ä»¥æ‰¾åˆ°load_imagesæ–¹æ³•çš„å…·ä½“å®žçŽ°ï¼Œä»£ç å¦‚ä¸‹ 123456789101112131415161718192021222324252627/************************************************************************ load_images* Process +load in the given images which are being mapped in by dyld.** Locking: write-locks runtimeLock and loadMethodLock**********************************************************************/extern bool hasLoadMethods(const headerType *mhdr);extern void prepare_load_methods(const headerType *mhdr);voidload_images(const char *path __unused, const struct mach_header *mh)&#123; // Return without taking locks if there are no +load methods here. if (!hasLoadMethods((const headerType *)mh)) return; recursive_mutex_locker_t lock(loadMethodLock); // Discover load methods &#123; rwlock_writer_t lock2(runtimeLock); prepare_load_methods((const headerType *)mh); &#125; // Call +load methods (without runtimeLock - re-entrant) call_load_methods();&#125; åœ¨è¿™é‡Œæˆ‘ä»¬å¯ä»¥å‘çŽ°ä¸¤ä¸ªå…³é”®çš„æ–¹æ³•ï¼Œprepare_load_methods(â€¦) call_load_methods() 12345678910111213141516171819202122void prepare_load_methods(const headerType *mhdr)&#123; size_t count, i; runtimeLock.assertWriting(); classref_t *classlist = _getObjc2NonlazyClassList(mhdr, &amp;count); for (i = 0; i &lt; count; i++) &#123; schedule_class_load(remapClass(classlist[i])); &#125; category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count); for (i = 0; i &lt; count; i++) &#123; category_t *cat = categorylist[i]; Class cls = remapClass(cat-&gt;cls); if (!cls) continue; // category for ignored weak-linked class realizeClass(cls); assert(cls-&gt;ISA()-&gt;isRealized()); add_category_to_loadable_list(cat); &#125;&#125; 12345678static void schedule_class_load(Class cls)&#123; if (cls-&gt;info &amp; CLS_LOADED) return; if (cls-&gt;superclass) schedule_class_load(cls-&gt;superclass); printf("%s\n\n",class_getName(cls)); add_class_to_loadable_list(cls); cls-&gt;info |= CLS_LOADED;&#125; å…¶ä¸­æˆ‘ä»¬åœ¨void prepare_load_methods(const headerType *mhdr)æ–¹æ³•ä¸­æ˜Žæ˜¾å¯ä»¥çœ‹å‡ºï¼Œå…ˆå¤„ç†Classçš„ç›¸å…³ä¿¡æ¯ï¼ŒåŽå¤„ç†Categoryçš„ç›¸å…³ä¿¡æ¯ï¼Œåœ¨å¤„ç†Classæ—¶ä¼šè¿›å…¥åˆ°static void schedule_class_load(Class cls)æ–¹æ³•ä¸­,åœ¨æ­¤æ–¹æ³•ä¸­ä¼šé€’å½’çš„å¯»æ‰¾åˆ°çˆ¶ç±»ï¼Œç„¶åŽè°ƒç”¨å…¶add_class_to_loadable_list(cls)çš„ä¿¡æ¯ 1234567891011121314151617181920212223242526void add_class_to_loadable_list(Class cls)&#123; IMP method; loadMethodLock.assertLocked(); method = cls-&gt;getLoadMethod(); if (!method) return; // Don't bother if cls has no +load method if (PrintLoading) &#123; _objc_inform("LOAD: class '%s' scheduled for +load", cls-&gt;nameForLogging()); &#125; if (loadable_classes_used == loadable_classes_allocated) &#123; loadable_classes_allocated = loadable_classes_allocated*2 + 16; loadable_classes = (struct loadable_class *) realloc(loadable_classes, loadable_classes_allocated * sizeof(struct loadable_class)); &#125; loadable_classes[loadable_classes_used].cls = cls; loadable_classes[loadable_classes_used].method = method; loadable_classes_used++;&#125; åœ¨è¿™é‡Œåˆ¤æ–­äº†Classä¸­æ˜¯å¦å®žçŽ°äº†+loadæ–¹æ³•,è‹¥å®žçŽ°äº†æŠŠè¯¥Classé¡ºåºå­˜å‚¨åˆ°loadable_classesä¸­,CategoryåŒç†ä¹Ÿè°ƒç”¨äº†ç›¸å…³æ–¹æ³•ï¼Œå°†å®žçŽ°çš„loadæ–¹æ³•çš„categoryæ·»åŠ åˆ°äº†listä¸­ï¼Œå¦‚ä¸‹å›¾ 12345678910111213141516171819202122232425262728293031323334/************************************************************************ add_category_to_loadable_list* Category cat's parent class exists and the category has been attached* to its class. Schedule this category for +load after its parent class* becomes connected and has its own +load method called.**********************************************************************/void add_category_to_loadable_list(Category cat)&#123; IMP method; loadMethodLock.assertLocked(); method = _category_getLoadMethod(cat); // Don't bother if cat has no +load method if (!method) return; if (PrintLoading) &#123; _objc_inform("LOAD: category '%s(%s)' scheduled for +load", _category_getClassName(cat), _category_getName(cat)); &#125; if (loadable_categories_used == loadable_categories_allocated) &#123; loadable_categories_allocated = loadable_categories_allocated*2 + 16; loadable_categories = (struct loadable_category *) realloc(loadable_categories, loadable_categories_allocated * sizeof(struct loadable_category)); &#125; loadable_categories[loadable_categories_used].cat = cat; loadable_categories[loadable_categories_used].method = method; loadable_categories_used++;&#125; åˆ°è¿™é‡Œprepare_load_methods(â€¦)è¿™ä¸ªæ–¹æ³•çš„ä½¿å‘½å°±ç®—ç»“æŸäº†ï¼Œæˆ‘ä»¬æ‰¾åˆ°äº†å¯ä»¥æ‰§è¡Œloadæ–¹æ³•çš„Classå’ŒCategoryï¼ŒæŽ¥ä¸‹æ¥è®©æˆ‘ä»¬çœ‹ä¸€ä¸‹æ‰§è¡Œçš„æ­¥éª¤ 1234567891011121314151617181920212223242526272829void call_load_methods(void)&#123; static bool loading = NO; bool more_categories; loadMethodLock.assertLocked(); // Re-entrant calls do nothing; the outermost call will finish the job. if (loading) return; loading = YES; void *pool = objc_autoreleasePoolPush(); do &#123; // 1. Repeatedly call class +loads until there aren't any more while (loadable_classes_used &gt; 0) &#123; call_class_loads(); &#125; // 2. Call category +loads ONCE more_categories = call_category_loads(); // 3. Run more +loads if there are classes OR more untried categories &#125; while (loadable_classes_used &gt; 0 || more_categories); objc_autoreleasePoolPop(pool); loading = NO;&#125; å…³é”®æ–¹æ³• call_class_loads() call_category_loads(),å¯ä»¥çœ‹å‡ºæ˜¯å…ˆæ‰§è¡Œçš„Classä¸­çš„loadæ–¹æ³•ï¼Œå†æ‰§è¡ŒCategoryä¸­çš„loadæ–¹æ³•ï¼Œä¸‹é¢æ˜¯ä¸¤ä¸ªæ–¹æ³•çš„å…·ä½“å®žçŽ° 123456789101112131415161718192021222324252627282930313233/************************************************************************ call_class_loads* Call all pending class +load methods.* If new classes become loadable, +load is NOT called for them.** Called only by call_load_methods().**********************************************************************/static void call_class_loads(void)&#123; int i; // Detach current loadable list. struct loadable_class *classes = loadable_classes; int used = loadable_classes_used; loadable_classes = nil; loadable_classes_allocated = 0; loadable_classes_used = 0; // Call all +loads for the detached list. for (i = 0; i &lt; used; i++) &#123; Class cls = classes[i].cls; load_method_t load_method = (load_method_t)classes[i].method; if (!cls) continue; if (PrintLoading) &#123; _objc_inform("LOAD: +[%s load]\n", cls-&gt;nameForLogging()); &#125; (*load_method)(cls, SEL_load); &#125; // Destroy the detached list. if (classes) free(classes);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/************************************************************************ call_category_loads* Call some pending category +load methods.* The parent class of the +load-implementing categories has all of * its categories attached, in case some are lazily waiting for +initalize.* Don&apos;t call +load unless the parent class is connected.* If new categories become loadable, +load is NOT called, and they * are added to the end of the loadable list, and we return TRUE.* Return FALSE if no new categories became loadable.** Called only by call_load_methods().**********************************************************************/static bool call_category_loads(void)&#123; int i, shift; bool new_categories_added = NO; // Detach current loadable list. struct loadable_category *cats = loadable_categories; int used = loadable_categories_used; int allocated = loadable_categories_allocated; loadable_categories = nil; loadable_categories_allocated = 0; loadable_categories_used = 0; // Call all +loads for the detached list. for (i = 0; i &lt; used; i++) &#123; Category cat = cats[i].cat; load_method_t load_method = (load_method_t)cats[i].method; Class cls; if (!cat) continue; cls = _category_getClass(cat); if (cls &amp;&amp; cls-&gt;isLoadable()) &#123; if (PrintLoading) &#123; _objc_inform(&quot;LOAD: +[%s(%s) load]\n&quot;, cls-&gt;nameForLogging(), _category_getName(cat)); &#125; (*load_method)(cls, SEL_load); cats[i].cat = nil; &#125; &#125; // Compact detached list (order-preserving) shift = 0; for (i = 0; i &lt; used; i++) &#123; if (cats[i].cat) &#123; cats[i-shift] = cats[i]; &#125; else &#123; shift++; &#125; &#125; used -= shift; // Copy any new +load candidates from the new list to the detached list. new_categories_added = (loadable_categories_used &gt; 0); for (i = 0; i &lt; loadable_categories_used; i++) &#123; if (used == allocated) &#123; allocated = allocated*2 + 16; cats = (struct loadable_category *) realloc(cats, allocated * sizeof(struct loadable_category)); &#125; cats[used++] = loadable_categories[i]; &#125; // Destroy the new list. if (loadable_categories) free(loadable_categories); // Reattach the (now augmented) detached list. // But if there&apos;s nothing left to load, destroy the list. if (used) &#123; loadable_categories = cats; loadable_categories_used = used; loadable_categories_allocated = allocated; &#125; else &#123; if (cats) free(cats); loadable_categories = nil; loadable_categories_used = 0; loadable_categories_allocated = 0; &#125; if (PrintLoading) &#123; if (loadable_categories_used != 0) &#123; _objc_inform(&quot;LOAD: %d categories still waiting for +load\n&quot;, loadable_categories_used); &#125; &#125; return new_categories_added;&#125; æ€»ç»“+loadæ–¹æ³•é€šè¿‡å‡½æ•°æŒ‡é’ˆè°ƒç”¨ï¼Œè€Œä¸æ˜¯objc_msgSend+loadæ–¹æ³•çš„è°ƒç”¨æ—¶æœºæ˜¯åœ¨Runtimeåˆå§‹åŒ–çš„æ—¶å€™ï¼Œå…¶ä¸­çš„è°ƒç”¨é¡ºåºæ˜¯çˆ¶ç±»-&gt;å­ç±»-&gt;åˆ†ç±»ï¼Œå…¶ä¸­é»˜è®¤è°ƒç”¨ä¸€æ¬¡ï¼Œåœ¨Classä¸­å’ŒCategoryä¸­éƒ½å®žçŽ°äº†loadæ–¹æ³•ï¼Œåˆ™åœ¨ä¸¤è€…ä¹‹é—´éƒ½ä¼šè°ƒç”¨ï¼Œä¸”åœ¨å­ç±»å®žçŽ°+loadæ–¹æ³•æ—¶ä¸éœ€è¦æ˜¾ç¤ºçš„è°ƒç”¨[super load]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://blog.hi996.com/2016/10/18/hello-world/</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
