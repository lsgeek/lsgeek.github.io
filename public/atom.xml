<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hi996</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.hi996.com/"/>
  <updated>2017-04-06T09:52:44.000Z</updated>
  <id>http://blog.hi996.com/</id>
  
  <author>
    <name>Liuonion</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS大解密之Weak引用</title>
    <link href="http://blog.hi996.com/2017/04/06/iosweaks/"/>
    <id>http://blog.hi996.com/2017/04/06/iosweaks/</id>
    <published>2017-04-06T09:23:32.000Z</published>
    <updated>2017-04-06T09:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>assign与weak有什么区别？面试的时候常常会被问到此问题，我们会回答weak修饰在对象释放时会自动变为nil,那么底层是怎么实现的呢？今天让我们来探讨一下，本文使用的runtime源码为大神提供的可编译版本<a href="https://github.com/isaacselement/objc4-706" target="_blank" rel="external">objc4-706</a></p>
<h2 id="storeWeak…"><a href="#storeWeak…" class="headerlink" title="storeWeak…"></a>storeWeak…</h2><p>与weak相关的操作，应该都调用了次方法，稍后看一下这个方法的实现，首先做一下准备工作</p>
<p>我首先在项目中定义了两个类Person、Like实现如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@interface Person : NSObject</div><div class="line">@property (atomic,weak) Like *like;</div><div class="line">- (<span class="keyword">void</span>)logLikeAddress;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Person</div><div class="line">- (<span class="keyword">void</span>)logLikeAddress</div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%p"</span>,&amp;_like);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line"><span class="comment">// Like其实什么也没实现😂</span></div><div class="line">@interface Like : NSObject</div><div class="line">@end</div><div class="line">@implementation Like</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>其中main函数为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addLike</span><span class="params">(Person* person)</span></span></div><div class="line">&#123;</div><div class="line">    Like *like = [[Like alloc] init];</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,like);</div><div class="line">    [person logLikeAddress];</div><div class="line">    person.like = like;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span></div><div class="line">&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        <span class="comment">// insert code here...</span></div><div class="line">        Person *person = [[Person alloc] init];</div><div class="line">        addLike(person);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>准备工作已经就绪了，我们在<code>Person</code>的中<code>weak</code>修饰的属性下断点，并单步调试，会发现如下的函数调用栈</p>
<p><img src="http://omhkfini5.bkt.clouddn.com/b2.png" alt=""></p>
<p>我们发现了关键的函数<code>objc_storeWeak(...)</code>,下面我们要详细的探讨这一函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> HaveOld, <span class="keyword">bool</span> HaveNew, <span class="keyword">bool</span> CrashIfDeallocating&gt;</div><div class="line"><span class="function"><span class="keyword">static</span> id </span></div><div class="line"><span class="title">storeWeak</span><span class="params">(id *location, objc_object *newObj)</span></div><div class="line">&#123;</div><div class="line">    assert(HaveOld  ||  HaveNew);</div><div class="line">    <span class="keyword">if</span> (!HaveNew) assert(newObj == nil);</div><div class="line"></div><div class="line">    Class previouslyInitializedClass = nil;</div><div class="line">    id oldObj;</div><div class="line">    <span class="comment">// 新旧引用表创建</span></div><div class="line">    SideTable *oldTable;</div><div class="line">    SideTable *newTable;</div><div class="line"></div><div class="line">    <span class="comment">// Acquire locks for old and new values.</span></div><div class="line">    <span class="comment">// Order by lock address to prevent lock ordering problems. </span></div><div class="line">    <span class="comment">// Retry if the old value changes underneath us.</span></div><div class="line"> retry:</div><div class="line">    <span class="keyword">if</span> (HaveOld) &#123;</div><div class="line">        <span class="comment">// 获取旧引用表</span></div><div class="line">        oldObj = *location;</div><div class="line">        oldTable = &amp;SideTables()[oldObj];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        oldTable = nil;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (HaveNew) &#123;</div><div class="line">        <span class="comment">// 获取新引用表</span></div><div class="line">        newTable = &amp;SideTables()[newObj];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        newTable = nil;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 加锁</span></div><div class="line">    SideTable::lockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable);</div><div class="line">    <span class="comment">// location 应该与 oldObj 保持一致，否则重新获取</span></div><div class="line">    <span class="keyword">if</span> (HaveOld  &amp;&amp;  *location != oldObj) &#123;</div><div class="line">        SideTable::unlockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable);</div><div class="line">        <span class="keyword">goto</span> retry;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Prevent a deadlock between the weak reference machinery</span></div><div class="line">    <span class="comment">// and the +initialize machinery by ensuring that no </span></div><div class="line">    <span class="comment">// weakly-referenced object has an un-+initialized isa.</span></div><div class="line">    <span class="keyword">if</span> (HaveNew  &amp;&amp;  newObj) &#123;</div><div class="line">        Class cls = newObj-&gt;getIsa();</div><div class="line">        <span class="keyword">if</span> (cls != previouslyInitializedClass  &amp;&amp;  </div><div class="line">            !((objc_class *)cls)-&gt;isInitialized()) </div><div class="line">        &#123;</div><div class="line">            SideTable::unlockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable);</div><div class="line">            _class_initialize(_class_getNonMetaClass(cls, (id)newObj));</div><div class="line"></div><div class="line">            <span class="comment">// If this class is finished with +initialize then we're good.</span></div><div class="line">            <span class="comment">// If this class is still running +initialize on this thread </span></div><div class="line">            <span class="comment">// (i.e. +initialize called storeWeak on an instance of itself)</span></div><div class="line">            <span class="comment">// then we may proceed but it will appear initializing and </span></div><div class="line">            <span class="comment">// not yet initialized to the check above.</span></div><div class="line">            <span class="comment">// Instead set previouslyInitializedClass to recognize it on retry.</span></div><div class="line">            previouslyInitializedClass = cls;</div><div class="line"></div><div class="line">            <span class="keyword">goto</span> retry;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Clean up old value, if any. 清除旧值</span></div><div class="line">    <span class="keyword">if</span> (HaveOld) &#123;</div><div class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Assign new value, if any. 设置新值</span></div><div class="line">    <span class="keyword">if</span> (HaveNew) &#123;</div><div class="line">        newObj = (objc_object *)weak_register_no_lock(&amp;newTable-&gt;weak_table, </div><div class="line">                                                      (id)newObj, location, </div><div class="line">                                                      CrashIfDeallocating);</div><div class="line">        <span class="comment">// weak_register_no_lock returns nil if weak store should be rejected</span></div><div class="line"></div><div class="line">        <span class="comment">// Set is-weakly-referenced bit in refcount table.</span></div><div class="line">        <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</div><div class="line">            <span class="comment">// 标记该对象是一个弱引用</span></div><div class="line">            newObj-&gt;setWeaklyReferenced_nolock();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Do not set *location anywhere else. That would introduce a race.</span></div><div class="line">        *location = (id)newObj;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// No new value. The storage is not changed.</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    SideTable::unlockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (id)newObj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在此方法中，我们可以看见一些关键点， <code>SideTable</code>， <code>weak_unregister_no_lock(...)</code>， <code>weak_register_no_lock（...）</code>，下面我们会逐一介绍</p>
<h2 id="引用计数和弱引用依赖表-SideTable"><a href="#引用计数和弱引用依赖表-SideTable" class="headerlink" title="引用计数和弱引用依赖表 SideTable"></a>引用计数和弱引用依赖表 SideTable</h2><p>SideTable 是一个结构体，主要用于管理对象的引用计数和 weak 表。在 NSObject.mm 中声明其数据结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> SideTable &#123;</div><div class="line">    <span class="comment">//自旋锁</span></div><div class="line">    <span class="keyword">spinlock_t</span> slock;</div><div class="line">    <span class="comment">// 引用计数表</span></div><div class="line">    RefcountMap refcnts;</div><div class="line">    <span class="comment">// 弱引用表</span></div><div class="line">    <span class="keyword">weak_table_t</span> weak_table;</div><div class="line"></div><div class="line">    SideTable() &#123;</div><div class="line">        <span class="built_in">memset</span>(&amp;weak_table, <span class="number">0</span>, <span class="keyword">sizeof</span>(weak_table));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ~SideTable() &#123;</div><div class="line">        _objc_fatal(<span class="string">"Do not delete SideTable."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; slock.lock(); &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; slock.unlock(); &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Address-ordered lock discipline for a pair of side tables.</span></div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">bool</span> HaveOld, <span class="keyword">bool</span> HaveNew&gt;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lockTwo</span><span class="params">(SideTable *lock1, SideTable *lock2)</span></span>;</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">bool</span> HaveOld, <span class="keyword">bool</span> HaveNew&gt;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unlockTwo</span><span class="params">(SideTable *lock1, SideTable *lock2)</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>对于该结构体中的<code>slock</code>,<code>refcnts</code>,暂时我们不做讨论，我们主要讨论与弱引用相关的<code>weak_table</code>作用，其中<code>weak_table_t</code>的结构如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> <span class="keyword">weak_table_t</span> &#123;</div><div class="line">    <span class="comment">// 保存了所有指向指定对象的 weak 指针</span></div><div class="line">    <span class="keyword">weak_entry_t</span> *weak_entries;</div><div class="line">    <span class="comment">// 存储空间</span></div><div class="line">    <span class="keyword">size_t</span>    num_entries;</div><div class="line">    <span class="comment">// 参与判断引用计数辅助量</span></div><div class="line">    <span class="keyword">uintptr_t</span> mask;</div><div class="line">    <span class="comment">// hash key 最大偏移值</span></div><div class="line">    <span class="keyword">uintptr_t</span> max_hash_displacement;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这是一个全局弱引用表。使用不定类型对象的地址作为 key ，用<code>weak_entry_t</code>类型结构体对象作为value。其中的<code>weak_entries</code>成员，从字面意思上看，即为弱引用表入口。其实现也是这样的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> WEAK_INLINE_COUNT 4</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REFERRERS_OUT_OF_LINE 2</span></div><div class="line"><span class="keyword">struct</span> <span class="keyword">weak_entry_t</span> &#123;</div><div class="line">    DisguisedPtr&lt;objc_object&gt; referent;</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">struct</span> &#123;</div><div class="line">            <span class="keyword">weak_referrer_t</span> *referrers;</div><div class="line">            <span class="keyword">uintptr_t</span>        out_of_line_ness : <span class="number">2</span>;</div><div class="line">            <span class="keyword">uintptr_t</span>        num_refs : PTR_MINUS_2;</div><div class="line">            <span class="keyword">uintptr_t</span>        mask;</div><div class="line">            <span class="keyword">uintptr_t</span>        max_hash_displacement;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">struct</span> &#123;</div><div class="line">            <span class="comment">// out_of_line_ness field is low bits of inline_referrers[1]</span></div><div class="line">            <span class="keyword">weak_referrer_t</span>  inline_referrers[WEAK_INLINE_COUNT];</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">out_of_line</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (out_of_line_ness == REFERRERS_OUT_OF_LINE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">weak_entry_t</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">weak_entry_t</span>&amp; other) &#123;</div><div class="line">        <span class="built_in">memcpy</span>(<span class="keyword">this</span>, &amp;other, <span class="keyword">sizeof</span>(other));</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">weak_entry_t</span>(objc_object *newReferent, objc_object **newReferrer)</div><div class="line">        : referent(newReferent)</div><div class="line">    &#123;</div><div class="line">        inline_referrers[<span class="number">0</span>] = newReferrer;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</div><div class="line">            inline_referrers[i] = nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>让我们回到<code>storeWeak(...)</code>函数中，获取<code>oldTable</code>,与<code>newTable</code>,发现调用的函数为<code>&amp;SideTables()[newObj]</code>,<code>&amp;SideTables()[oldObj]</code>,其中该方法的实现为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">alignas(StripedMap&lt;SideTable&gt;) <span class="keyword">static</span> <span class="keyword">uint8_t</span> SideTableBuf[<span class="keyword">sizeof</span>(StripedMap&lt;SideTable&gt;)];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SideTableInit</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> (SideTableBuf) StripedMap&lt;SideTable&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">reinterpret_cast</span>&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> StripedMap &#123;</div><div class="line"></div><div class="line">    <span class="keyword">enum</span> &#123; CacheLineSize = <span class="number">64</span> &#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_EMBEDDED</span></div><div class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">8</span> &#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="keyword">enum</span> &#123; StripeCount = <span class="number">64</span> &#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="keyword">struct</span> PaddedT &#123;</div><div class="line">        <span class="function">T value <span class="title">alignas</span><span class="params">(CacheLineSize)</span></span>;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    PaddedT <span class="built_in">array</span>[StripeCount];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">indexForPointer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p)</span> </span>&#123;</div><div class="line">        <span class="keyword">uintptr_t</span> addr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(p);</div><div class="line">        <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">    T&amp; <span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">void</span> *p) &#123; </div><div class="line">        <span class="keyword">return</span> <span class="built_in">array</span>[indexForPointer(p)].value; </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">void</span> *p) <span class="keyword">const</span> &#123; </div><div class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;StripedMap&lt;T&gt;&gt;(<span class="keyword">this</span>)[p]; </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在上面我们可以看出<code>StripedMap</code>是一个模板类（Template Class），通过传入类（结构体）参数，会动态修改在该类中的一个 array 成员存储的元素类型，并且其中提供了一个针对于地址的 hash 算法，用作存储key。可以说， <code>StripedMap</code> 提供了一套拥有将地址作为 key 的 hash table 解决方案，而该方案采用了模板类，是拥有泛型性的,在这个类中有一个 array 成员，用来存储 <code>PaddedT</code> 对象，并且其中对于 [] 符的重载定义中，会返回这个 PaddedT 的 value 成员，这个 value 就是我们传入的 T 泛型成员，也就是 <code>SideTable</code> 对象。在 array 的下标中，这里使用了 <code>indexForPointer</code> 方法通过位运算计算下标，实现了静态的 Hash Table。而在 <code>weak_table</code> 中，其成员 <code>weak_entry</code>会将传入对象的地址加以封装起来，并且其中也有访问全局弱引用表的入口</p>
<h2 id="weak-register-no-lock-…"><a href="#weak-register-no-lock-…" class="headerlink" title="weak_register_no_lock(…)"></a>weak_register_no_lock(…)</h2><p>该方法将弱引用对象注册到弱引用表中，我们看一下它的具体实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="function">id </span></div><div class="line"><span class="title">weak_register_no_lock</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, id referent_id, </span></div><div class="line">                      id *referrer_id, <span class="keyword">bool</span> crashIfDeallocating)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// weak对象的引用 即like</span></div><div class="line">    objc_object *referent = (objc_object *)referent_id;</div><div class="line">    <span class="comment">// 指向weak对象的引用的指针 即Person对象中的&amp;like 可理解为&amp;(person.like)</span></div><div class="line">    objc_object **referrer = (objc_object **)referrer_id;</div><div class="line"></div><div class="line">    <span class="comment">//判断TaggedPointer</span></div><div class="line">    <span class="keyword">if</span> (!referent  ||  referent-&gt;isTaggedPointer()) <span class="keyword">return</span> referent_id;</div><div class="line"></div><div class="line">    <span class="comment">// ensure that the referenced object is viable 保证对象是可以访问的</span></div><div class="line">    <span class="keyword">bool</span> deallocating;</div><div class="line">    <span class="keyword">if</span> (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123;</div><div class="line">        deallocating = referent-&gt;rootIsDeallocating();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        BOOL (*allowsWeakReference)(objc_object *, SEL) = </div><div class="line">            (BOOL(*)(objc_object *, SEL))</div><div class="line">            object_getMethodImplementation((id)referent, </div><div class="line">                                           SEL_allowsWeakReference);</div><div class="line">        <span class="keyword">if</span> ((IMP)allowsWeakReference == _objc_msgForward) &#123;</div><div class="line">            <span class="keyword">return</span> nil;</div><div class="line">        &#125;</div><div class="line">        deallocating =</div><div class="line">            ! (*allowsWeakReference)(referent, SEL_allowsWeakReference);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (deallocating) &#123;</div><div class="line">        <span class="keyword">if</span> (crashIfDeallocating) &#123;</div><div class="line">            _objc_fatal(<span class="string">"Cannot form weak reference to instance (%p) of "</span></div><div class="line">                        <span class="string">"class %s. It is possible that this object was "</span></div><div class="line">                        <span class="string">"over-released, or is in the process of deallocation."</span>,</div><div class="line">                        (<span class="keyword">void</span>*)referent, object_getClassName((id)referent));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// now remember it and where it is being stored</span></div><div class="line">    <span class="keyword">weak_entry_t</span> *entry;</div><div class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</div><div class="line">        append_referrer(entry, referrer);</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 该对象第一次插入</span></div><div class="line">        <span class="keyword">weak_entry_t</span> new_entry(referent, referrer);</div><div class="line">        <span class="comment">// 是否需要扩容表长度</span></div><div class="line">        weak_grow_maybe(weak_table);</div><div class="line">        <span class="comment">// 插入表</span></div><div class="line">        weak_entry_insert(weak_table, &amp;new_entry);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Do not set *referrer. objc_storeWeak() requires that the </span></div><div class="line">    <span class="comment">// value not change.</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> referent_id;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结一下，我们weak对象的引用,与指向weak对象的引用，传入此函数中，假设是首次保存此weak对象的引用，构建出<code>weak_entry_t</code>的实例<br><code>new_entry</code>,判断当前的弱引用表是否需要增加长度，然后将<code>new_entry</code>插入到弱引用表<code>weak_table</code>中；如若不是第一次保存，首先取出旧的<code>entry</code>，并将指向weak对象的引用（即&amp;(person.like)）保存在<code>entry</code>中。<br>所以可以看出，一个<code>entry</code>中保存了所有指向该weak对象的弱引用</p>
<h2 id="weak-unregister-no-lock-…"><a href="#weak-unregister-no-lock-…" class="headerlink" title="weak_unregister_no_lock(…)"></a>weak_unregister_no_lock(…)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">weak_unregister_no_lock</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, id referent_id, </span></div><div class="line">                        id *referrer_id)</div><div class="line">&#123;</div><div class="line">    objc_object *referent = (objc_object *)referent_id;</div><div class="line">    objc_object **referrer = (objc_object **)referrer_id;</div><div class="line"></div><div class="line">    <span class="keyword">weak_entry_t</span> *entry;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!referent) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</div><div class="line">        remove_referrer(entry, referrer);</div><div class="line">        <span class="keyword">bool</span> empty = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span> (entry-&gt;out_of_line()  &amp;&amp;  entry-&gt;num_refs != <span class="number">0</span>) &#123;</div><div class="line">            empty = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (entry-&gt;inline_referrers[i]) &#123;</div><div class="line">                    empty = <span class="literal">false</span>; </div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (empty) &#123;</div><div class="line">            weak_entry_remove(weak_table, entry);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Do not set *referrer = nil. objc_storeWeak() requires that the </span></div><div class="line">    <span class="comment">// value not change.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中该方法就是<code>remove_referrer(entry, referrer);</code>,在<code>entry</code>中移除了<code>referrer</code>,弱引用表中不再保存指向该weak对象的引用</p>
<h2 id="weak对象释放"><a href="#weak对象释放" class="headerlink" title="weak对象释放"></a>weak对象释放</h2><p><img src="http://omhkfini5.bkt.clouddn.com/weak2.png" alt=""><br>我们可以看见当一个被弱引用指向的对象释放时，会调用<code>weak_clear_no_lock(...)</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> </span></div><div class="line"><span class="title">weak_clear_no_lock</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, id referent_id)</span> </div><div class="line">&#123;</div><div class="line">    objc_object *referent = (objc_object *)referent_id;</div><div class="line"></div><div class="line">    <span class="keyword">weak_entry_t</span> *entry = weak_entry_for_referent(weak_table, referent);</div><div class="line">    <span class="keyword">if</span> (entry == nil) &#123;</div><div class="line">        <span class="comment">/// XXX shouldn't happen, but does with mismatched CF/objc</span></div><div class="line">        <span class="comment">//printf("XXX no entry for clear deallocating %p\n", referent);</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// zero out references</span></div><div class="line">    <span class="keyword">weak_referrer_t</span> *referrers;</div><div class="line">    <span class="keyword">size_t</span> count;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line()) &#123;</div><div class="line">        referrers = entry-&gt;referrers;</div><div class="line">        count = TABLE_SIZE(entry);</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        referrers = entry-&gt;inline_referrers;</div><div class="line">        count = WEAK_INLINE_COUNT;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">        objc_object **referrer = referrers[i];</div><div class="line">        <span class="keyword">if</span> (referrer) &#123;</div><div class="line">            <span class="keyword">if</span> (*referrer == referent) &#123;</div><div class="line">               <span class="comment">//weak指向的对象，在释放时会被置nil的关键</span></div><div class="line">                *referrer = nil;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*referrer) &#123;</div><div class="line">                _objc_inform(<span class="string">"__weak variable at %p holds %p instead of %p. "</span></div><div class="line">                             <span class="string">"This is probably incorrect use of "</span></div><div class="line">                             <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></div><div class="line">                             <span class="string">"Break on objc_weak_error to debug.\n"</span>, </div><div class="line">                             referrer, (<span class="keyword">void</span>*)*referrer, (<span class="keyword">void</span>*)referent);</div><div class="line">                objc_weak_error();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    weak_entry_remove(weak_table, entry);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如方法中，通过<code>referent</code>,找到保存指向该对象的所有引用的实例<code>entry</code>，通过循环，将<code>entry</code>中的所有引用置为<code>nil</code>即可</p>
<h2 id="weak引用表图解"><a href="#weak引用表图解" class="headerlink" title="weak引用表图解"></a>weak引用表图解</h2><p><img src="http://omhkfini5.bkt.clouddn.com/weak5.png" alt=""></p>
<p>参考资料<br><br><a href="http://www.jianshu.com/p/ef6d9bf8fe59" target="_blank" rel="external">http://www.jianshu.com/p/ef6d9bf8fe59</a><br><br><a href="http://kylinroc.github.io/objc-retain-release.html" target="_blank" rel="external">http://kylinroc.github.io/objc-retain-release.html</a><br><br><a href="http://ios.jobbole.com/89012/" target="_blank" rel="external">http://ios.jobbole.com/89012/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;assign与weak有什么区别？面试的时候常常会被问到此问题，我们会回答weak修饰在对象释放时会自动变为nil,那么底层是怎么实现的呢？
    
    </summary>
    
      <category term="iOS" scheme="http://blog.hi996.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://blog.hi996.com/tags/iOS/"/>
    
      <category term="Runtime" scheme="http://blog.hi996.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>iOS大解密之Load方法</title>
    <link href="http://blog.hi996.com/2017/03/08/iOS-load-methodDes/"/>
    <id>http://blog.hi996.com/2017/03/08/iOS-load-methodDes/</id>
    <published>2017-03-08T09:45:43.000Z</published>
    <updated>2017-03-08T10:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>受益于苹果的封闭生态，开发者常常不必关注太多的底层细节，就能做出界面美观，性能优良的App，当然其中Apple也大方的开放出了少许的源码，例如Runtime源码,感谢<a href="http://blog.csdn.net/wotors/article/details/54426316" target="_blank" rel="external">http://blog.csdn.net/wotors/article/details/54426316</a> 提供了可以编译成功的源码工程。</p>
<h2 id="load"><a href="#load" class="headerlink" title="+load()"></a>+load()</h2><p>我们来通过源码来探讨一下load方法的加载时机，和在父类，Category中的加载顺序</p>
<p>首先我们在+load方法中打上断点，看到如下的执行过程</p>
<p><img src="http://omhkfini5.bkt.clouddn.com/load.jpg" alt=""></p>
<p>通过runtime的源码我们可以找到load_images方法的具体实现，代码如下</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/***********************************************************************</span></div><div class="line">* load_images</div><div class="line">* Process +load in the given images which are being mapped in by dyld.</div><div class="line">*</div><div class="line">* Locking: write-locks runtimeLock and loadMethodLock</div><div class="line">**********************************************************************/</div><div class="line"><span class="keyword">extern</span> <span class="keyword">bool</span> hasLoadMethods(<span class="keyword">const</span> headerType *mhdr);</div><div class="line"><span class="keyword">extern</span> <span class="keyword">void</span> prepare_load_methods(<span class="keyword">const</span> headerType *mhdr);</div><div class="line"></div><div class="line"><span class="keyword">void</span></div><div class="line">load_images(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> <span class="keyword">struct</span> mach_header *mh)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    recursive_mutex_locker_t lock(loadMethodLock);</div><div class="line"></div><div class="line">    <span class="comment">// Discover load methods</span></div><div class="line">    &#123;</div><div class="line">        rwlock_writer_t lock2(runtimeLock);</div><div class="line">        prepare_load_methods((<span class="keyword">const</span> headerType *)mh);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></div><div class="line">    call_load_methods();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里我们可以发现两个关键的方法，prepare_load_methods(…) call_load_methods()</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> prepare_load_methods(<span class="keyword">const</span> headerType *mhdr)</div><div class="line">&#123;</div><div class="line">    size_t count, i;</div><div class="line"></div><div class="line">    runtimeLock.assertWriting();</div><div class="line"></div><div class="line">    classref_t *classlist = </div><div class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">        schedule_class_load(remapClass(classlist[i]));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">        category_t *cat = categorylist[i];</div><div class="line">        Class cls = remapClass(cat-&gt;cls);</div><div class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></div><div class="line">        realizeClass(cls);</div><div class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</div><div class="line">        add_category_to_loadable_list(cat);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> schedule_class_load(Class cls)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (cls-&gt;info &amp; <span class="built_in">CLS_LOADED</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">if</span> (cls-&gt;superclass) schedule_class_load(cls-&gt;superclass);</div><div class="line">    printf(<span class="string">"%s\n\n"</span>,class_getName(cls));</div><div class="line">    add_class_to_loadable_list(cls);</div><div class="line">    cls-&gt;info |= <span class="built_in">CLS_LOADED</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中我们在void prepare_load_methods(const headerType *mhdr)方法中明显可以看出，先处理Class的相关信息，后处理Category的相关信息，在处理Class时会进入到static void schedule_class_load(Class cls)方法中,在此方法中会递归的寻找到父类，然后调用其add_class_to_loadable_list(cls)的信息</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> add_class_to_loadable_list(Class cls)</div><div class="line">&#123;</div><div class="line">    IMP method;</div><div class="line"></div><div class="line">    loadMethodLock.assertLocked();</div><div class="line"></div><div class="line">    method = cls-&gt;getLoadMethod();</div><div class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don't bother if cls has no +load method</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</div><div class="line">        _objc_inform(<span class="string">"LOAD: class '%s' scheduled for +load"</span>, </div><div class="line">                     cls-&gt;nameForLogging());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</div><div class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</div><div class="line">        loadable_classes = (<span class="keyword">struct</span> loadable_class *)</div><div class="line">            realloc(loadable_classes,</div><div class="line">                              loadable_classes_allocated *</div><div class="line">                              <span class="keyword">sizeof</span>(<span class="keyword">struct</span> loadable_class));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    loadable_classes[loadable_classes_used].cls = cls;</div><div class="line">    loadable_classes[loadable_classes_used].method = method;</div><div class="line">    loadable_classes_used++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里判断了Class中是否实现了+load方法,若实现了把该Class顺序存储到loadable_classes中,Category同理也调用了相关方法，将实现的load方法的category添加到了list中，如下图</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/***********************************************************************</span></div><div class="line">* add_category_to_loadable_list</div><div class="line">* Category cat's parent class exists and the category has been attached</div><div class="line">* to its class. Schedule this category for +load after its parent class</div><div class="line">* becomes connected and has its own +load method called.</div><div class="line">**********************************************************************/</div><div class="line"><span class="keyword">void</span> add_category_to_loadable_list(Category cat)</div><div class="line">&#123;</div><div class="line">    IMP method;</div><div class="line"></div><div class="line">    loadMethodLock.assertLocked();</div><div class="line"></div><div class="line">    method = _category_getLoadMethod(cat);</div><div class="line"></div><div class="line">    <span class="comment">// Don't bother if cat has no +load method</span></div><div class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</div><div class="line">        _objc_inform(<span class="string">"LOAD: category '%s(%s)' scheduled for +load"</span>, </div><div class="line">                     _category_getClassName(cat), _category_getName(cat));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (loadable_categories_used == loadable_categories_allocated) &#123;</div><div class="line">        loadable_categories_allocated = loadable_categories_allocated*<span class="number">2</span> + <span class="number">16</span>;</div><div class="line">        loadable_categories = (<span class="keyword">struct</span> loadable_category *)</div><div class="line">            realloc(loadable_categories,</div><div class="line">                              loadable_categories_allocated *</div><div class="line">                              <span class="keyword">sizeof</span>(<span class="keyword">struct</span> loadable_category));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    loadable_categories[loadable_categories_used].cat = cat;</div><div class="line">    loadable_categories[loadable_categories_used].method = method;</div><div class="line">    loadable_categories_used++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里prepare_load_methods(…)这个方法的使命就算结束了，我们找到了可以执行load方法的Class和Category，接下来让我们看一下执行的步骤</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> call_load_methods(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = <span class="literal">NO</span>;</div><div class="line">    <span class="keyword">bool</span> more_categories;</div><div class="line"></div><div class="line">    loadMethodLock.assertLocked();</div><div class="line"></div><div class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></div><div class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</div><div class="line">    loading = <span class="literal">YES</span>;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</div><div class="line"></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></div><div class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</div><div class="line">            call_class_loads();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 2. Call category +loads ONCE</span></div><div class="line">        more_categories = call_category_loads();</div><div class="line"></div><div class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></div><div class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</div><div class="line"></div><div class="line">    objc_autoreleasePoolPop(pool);</div><div class="line"></div><div class="line">    loading = <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关键方法 call_class_loads() call_category_loads(),可以看出是先执行的Class中的load方法，再执行Category中的load方法，下面是两个方法的具体实现</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/***********************************************************************</span></div><div class="line">* call_class_loads</div><div class="line">* Call all pending class +load methods.</div><div class="line">* If new classes become loadable, +load is NOT called for them.</div><div class="line">*</div><div class="line">* Called only by call_load_methods().</div><div class="line">**********************************************************************/</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> call_class_loads(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    </div><div class="line">    <span class="comment">// Detach current loadable list.</span></div><div class="line">    <span class="keyword">struct</span> loadable_class *classes = loadable_classes;</div><div class="line">    <span class="keyword">int</span> used = loadable_classes_used;</div><div class="line">    loadable_classes = <span class="literal">nil</span>;</div><div class="line">    loadable_classes_allocated = <span class="number">0</span>;</div><div class="line">    loadable_classes_used = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// Call all +loads for the detached list.</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</div><div class="line">        Class cls = classes[i].cls;</div><div class="line">        load_method_t load_method = (load_method_t)classes[i].method;</div><div class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (PrintLoading) &#123;</div><div class="line">            _objc_inform(<span class="string">"LOAD: +[%s load]\n"</span>, cls-&gt;nameForLogging());</div><div class="line">        &#125;</div><div class="line">        (*load_method)(cls, SEL_load);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Destroy the detached list.</span></div><div class="line">    <span class="keyword">if</span> (classes) free(classes);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">/***********************************************************************</div><div class="line">* call_category_loads</div><div class="line">* Call some pending category +load methods.</div><div class="line">* The parent class of the +load-implementing categories has all of </div><div class="line">*   its categories attached, in case some are lazily waiting for +initalize.</div><div class="line">* Don&apos;t call +load unless the parent class is connected.</div><div class="line">* If new categories become loadable, +load is NOT called, and they </div><div class="line">*   are added to the end of the loadable list, and we return TRUE.</div><div class="line">* Return FALSE if no new categories became loadable.</div><div class="line">*</div><div class="line">* Called only by call_load_methods().</div><div class="line">**********************************************************************/</div><div class="line">static bool call_category_loads(void)</div><div class="line">&#123;</div><div class="line">    int i, shift;</div><div class="line">    bool new_categories_added = NO;</div><div class="line">    </div><div class="line">    // Detach current loadable list.</div><div class="line">    struct loadable_category *cats = loadable_categories;</div><div class="line">    int used = loadable_categories_used;</div><div class="line">    int allocated = loadable_categories_allocated;</div><div class="line">    loadable_categories = nil;</div><div class="line">    loadable_categories_allocated = 0;</div><div class="line">    loadable_categories_used = 0;</div><div class="line"></div><div class="line">    // Call all +loads for the detached list.</div><div class="line">    for (i = 0; i &lt; used; i++) &#123;</div><div class="line">        Category cat = cats[i].cat;</div><div class="line">        load_method_t load_method = (load_method_t)cats[i].method;</div><div class="line">        Class cls;</div><div class="line">        if (!cat) continue;</div><div class="line"></div><div class="line">        cls = _category_getClass(cat);</div><div class="line">        if (cls  &amp;&amp;  cls-&gt;isLoadable()) &#123;</div><div class="line">            if (PrintLoading) &#123;</div><div class="line">                _objc_inform(&quot;LOAD: +[%s(%s) load]\n&quot;, </div><div class="line">                             cls-&gt;nameForLogging(), </div><div class="line">                             _category_getName(cat));</div><div class="line">            &#125;</div><div class="line">            (*load_method)(cls, SEL_load);</div><div class="line">            cats[i].cat = nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Compact detached list (order-preserving)</div><div class="line">    shift = 0;</div><div class="line">    for (i = 0; i &lt; used; i++) &#123;</div><div class="line">        if (cats[i].cat) &#123;</div><div class="line">            cats[i-shift] = cats[i];</div><div class="line">        &#125; else &#123;</div><div class="line">            shift++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    used -= shift;</div><div class="line"></div><div class="line">    // Copy any new +load candidates from the new list to the detached list.</div><div class="line">    new_categories_added = (loadable_categories_used &gt; 0);</div><div class="line">    for (i = 0; i &lt; loadable_categories_used; i++) &#123;</div><div class="line">        if (used == allocated) &#123;</div><div class="line">            allocated = allocated*2 + 16;</div><div class="line">            cats = (struct loadable_category *)</div><div class="line">                realloc(cats, allocated *</div><div class="line">                                  sizeof(struct loadable_category));</div><div class="line">        &#125;</div><div class="line">        cats[used++] = loadable_categories[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Destroy the new list.</div><div class="line">    if (loadable_categories) free(loadable_categories);</div><div class="line"></div><div class="line">    // Reattach the (now augmented) detached list. </div><div class="line">    // But if there&apos;s nothing left to load, destroy the list.</div><div class="line">    if (used) &#123;</div><div class="line">        loadable_categories = cats;</div><div class="line">        loadable_categories_used = used;</div><div class="line">        loadable_categories_allocated = allocated;</div><div class="line">    &#125; else &#123;</div><div class="line">        if (cats) free(cats);</div><div class="line">        loadable_categories = nil;</div><div class="line">        loadable_categories_used = 0;</div><div class="line">        loadable_categories_allocated = 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (PrintLoading) &#123;</div><div class="line">        if (loadable_categories_used != 0) &#123;</div><div class="line">            _objc_inform(&quot;LOAD: %d categories still waiting for +load\n&quot;,</div><div class="line">                         loadable_categories_used);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return new_categories_added;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>+load方法通过函数指针调用，而不是objc_msgSend<br>+load方法的调用时机是在Runtime初始化的时候，其中的调用顺序是父类-&gt;子类-&gt;分类，其中默认调用一次，在Class中和Category中都实现了load方法，则在两者之间都会调用，且在子类实现+load方法时不需要显示的调用[super load]</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;受益于苹果的封闭生态，开发者常常不必关注太多的底层细节，就能做出界面美观，性能优良的App，当然其中Apple也大方的开放出了少许的源码，例如Runtime源码,感谢&lt;a href=&quot;http://blog.csdn.net/wotors/article/details/5
    
    </summary>
    
    
      <category term="iOS" scheme="http://blog.hi996.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://blog.hi996.com/2016/10/18/hello-world/"/>
    <id>http://blog.hi996.com/2016/10/18/hello-world/</id>
    <published>2016-10-18T03:25:02.000Z</published>
    <updated>2016-10-19T11:12:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
      <category term="Hello World" scheme="http://blog.hi996.com/categories/Hello-World/"/>
    
    
      <category term="Hello World" scheme="http://blog.hi996.com/tags/Hello-World/"/>
    
  </entry>
  
</feed>
